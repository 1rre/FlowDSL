\chapter{Introduction}
This project centres around the design, implementation and evaluation of a DSL, Flow DSL, for converting static streaming dataflow graphs, such as the one in figureÂ \ref{intro.dataflow}, into hardware. In parallel, the project investigates the potential applications of the static streaming dataflow model in other programming domains and for other targets. The DSL itself is designed to be reconfigurable, easy to learn and intuitive to people who know Python. It is dissimilar to most existing hardware development languages, abstracting away the concept of registers, a clock and other features which may serve to unnecessarily complicate the DSL, as exposing clock logic is not necessary when inputs and outputs arrive and leave every clock cycle. A functionally equivalent Verilog code listing for the can be seen in listing \ref{verilog.roberts_cross}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}\centering
    \caption*{}
    \begin{minted}[numbers=left]{python}
screen_height = 480

r_in = gr.istream(8)
g_in = gr.istream(8)
b_in = gr.istream(8)

def roberts_cross(in0: Node) -> Node:
  last = in0.offset(-1)
  prev_row = in0.offset(-screen_height)
  prev_row_last = last.offset(-screen_height)
  gx = in0 - prev_row_last
  gy = prev_row - last
  return abs(gx) + abs(gy)

r_out = gr.ostream(roberts_cross(r_in), 8)
g_out = gr.ostream(roberts_cross(g_in), 8)
b_out = gr.ostream(roberts_cross(b_in), 8)
    \end{minted}
    \caption{Flow DSL}
  \end{subfigure}%
  \begin{subfigure}[b]{0.5\textwidth}\centering
    \caption*{}
    \begin{tikzpicture}[node distance=1cm,circuit ee IEC]
      % below n
      \node (n) {$[rgb_{-n}, ..., rgb_{-1}, rgb_0, rgb_1, ..., rgb_{n}]$};
      \node (buf_0) [buf,below left=of n,xshift=1.5cm]{$last_{480}$};
      \node (buf_1) [buf,right=of buf_0,xshift=-0.5cm]{$last_1$};
      \node (sub_0) [op, below=of buf_1,xshift=-0.5cm]{$-$};
      \node (abs_0) [op, below=of sub_0,yshift=1cm,xshift=1cm]{abs};
      \node (buf_2) [buf,below right=of n,xshift=-2cm]{$last_{481}$};
      \node (sub_1) [op, right=of sub_0,xshift=2cm]{$-$};
      \node (abs_1) [op, below=of sub_1,yshift=1cm,xshift=-1cm]{abs};
      \node (add_0) [op, right=of abs_0,yshift=-1cm,xshift=-1cm]{$+$};
      \node (y) [below=of add_0] {$[out_{-n}, ..., out_{-1}, out_0, out_1, ..., out_{n}]$};
      \draw[->](n)--(buf_0);
      \draw[->](n)--(buf_1);
      \draw[->](buf_0)--(sub_0);
      \draw[->](buf_1)--(sub_0);
      \draw[->](sub_0)--(abs_0);
      \draw[->](abs_0)--(add_0);
      \draw[->](n)--(buf_2);
      \draw[->](buf_2)--(sub_1);
      \draw[->](n)--(sub_1);
      \draw[->](sub_1)--(abs_1);
      \draw[->](abs_1)--(add_0);
      \draw[->](add_0)--(y);
    \end{tikzpicture}
    \caption{Dataflow Graph}
  \end{subfigure}
  \caption{Roberts Cross edge detector}\label{intro.dataflow}
\end{figure}

\section{Motivation}
Stream processing, the practice of sequentially processing data records at a constant rate as defined by external factors, is increasingly used in diverse fields such as data analytics, digital signal processing, and network security. With the growing amount of data generated by modern applications, efficient and reliable stream processing has become a critical requirement, often necessitating the use of hardware acceleration to meet performance and latency goals \hyphen{} indeed stream processing is one of the most popular applications for hardware acceleration.

Despite the popularity of stream processing, existing hardware design tools suitable for its implementation often suffer from high entry barriers, outdated practices, or convoluted or `boilerplate' filled syntaxes. This creates a challenging landscape for system designers, often pushing them to use low-level Register Transfer Level (RTL) languages like Verilog or VHDL, or to use more general High-Level Synthesis (HLS) tools which often require sacrificing control over timing or the level of optimisation which can be applied. In both cases, the potential loss of fine-grained control crucial to achieving a specific throughput and the prioritization of latency in HLS tools can be problematic for stream processing.

Existing toolkits for stream processing hardware acceleration are often poorly documented and commercially restricted, limiting their accessibility, especially for individual developers and researchers. This project intends to fill this gap with an accessible, user-friendly tool.

Interestingly, the concepts underpinning stream processing show considerable overlap with declarative programming. The notion of reaching definitions which may even be forward references found in declarative languages has many parallels with the static streaming paradigm. The immutability of hardware variables within a hardware clock cycle also aligns with the principles of functional and declarative programming. This overlap suggests the potential for a domain-specific language (DSL) catering to stream processing hardware that borrows principles from declarative programming.


\section{Technical Challenges}
\subsection{General Challenges}
\subsubsection*{Synthesisability}
Designing a new DSL for hardware acceleration comes with the challenge of ensuring synthesisability. The language constructs and the operations expressed must be synthesisable into hardware constructs. This involves ensuring that the language elements can be mapped onto hardware primitives such as gates, flip-flops, memories, and arithmetic units, or to a subset of an RTL-supporting HDL which allows for relatively low level specification of hardware.
\subsubsection*{Retiming Algorithms}
Developing retiming algorithms to optimise the performance of hardware designs is another challenge. Even in the simpler dataflow domain, developing such algorithms is nontrivial, as retiming certain nodes may have knock-on effects on the others. There is also the consideration of balancing latency against resource usage.
\subsubsection*{Evaluation}
A new DSL and the associated IR dialects need extensive testing and evaluation. This requires developing benchmarks and performance metrics, implementing test cases, and possibly also creating hardware prototypes. These activities are time-consuming and require tailoring both to the domain from which the test case comes and the hardware architectures it will be deployed to.

\subsection{Implementation Specific Challenges}
\subsubsection*{Limitations of Python}
While Python will be a powerful tool for the programmer of Flow DSL programs, it presents a number of challenges for writing the DSL, the most major of which being the lack of a strong type system. As polymorphism and the type system in general in Python isn't powerful compared to those in many other languages, a lot more compile time type verification is required when compared to that in other languages, as there is no Python compiler to do the work for us.

\section{Contributions}
\subsection*{Design and implementation of the Flow DSL}
Designing new domain-specific language that simplifies the design of stream processing hardware. The language provides high-level abstractions and an intuitive syntax, making it easy for designers to express complex algorithms and designs as a dataflow graph.

\subsection*{Analysis and implementation of retiming algorithms}
Designing retiming algorithms that cater specifically to the needs of dataflow-based stream processing. These algorithms are distinguished in their ability to allow for full cycles, either backwards or forwards. This feature stands in contrast to many existing languages that only support accumulators or referencing previous values without the possibility of forward references or getting future values. By supporting a broader range of retiming operations, our algorithms offer increased flexibility and optimization potential in hardware design, enhancing the efficacy of the overall system.

\subsection*{Development and implementation of xDSL dialects}
Developing and implementing dialects within the xDSL platform, which may be reusable for other HLS tools, which facilitate a multi-stage lowering structure. Currently, we support one high-level, two mid-level, and one low-level dialect, the latter of which can be translated into Verilog, a common hardware description language. Although only Verilog is currently supported as the target language, the advantage of the lowering design is its flexibility. The independent IR allows for easy retargeting to other hardware description languages or simulators in the future. This provides a path for extending the applicability of our DSL to a broader range of hardware design workflows without needing extensive redesign.

\subsection*{Reduction of `boilerplate' in hardware synthesis}
One of the key contributions of this project is the significant reduction of boilerplate code that is typically required when designing hardware using traditional RTL languages or HLS tools. With our DSL, users can focus on expressing their algorithms as a dataflow graph, while the tool takes care of the lower-level hardware implementation details. As the compiler is written in Python, there is little setup needed on a machine running it, and little extra code needed to get started. This results in more efficient hardware design practices, faster prototyping, and ultimately shorter time-to-market.

\subsection*{Creation of a framework with high optimisation potential}
An issue with many existing HLS frameworks is that there is limited scope for optimisation, as bit widths and timing of all variables is generally set at compile time. The Flow DSL is not subject to these limitations, as the timing is only fixed on inputs and the bit widths are only fixed on inputs and outputs at the beginning of the compilation process. This allows for more flexibility and optimisation during the compilation process, resulting in more efficient hardware designs.

\subsection*{Evaluation and testing of the DSL}
The DSL was evaluated and compared to existing popular HDL languages which allow full control of the clock to have a throughput of one value per input or output per clock cycle. As performance differs greatly between applications due the the multipliers, logic elements and buffers available on a given FPGA, a more widely applicable method of objective comparison had to be selected. Evaluation was also done on the more subjective features of the language, such as its verbosity, ease of writing and ease of modification.