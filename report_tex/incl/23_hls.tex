\section{Hardware Design Languages}\label{hls}
Hardware Design Languages (HDLs) are specialised programming languages used to design digital logic systems, such as field-programmable gate arrays (FPGAs) and application specific integrated circuits (ASICs). HDLs allow designers to describe the structure, functionality, and timing of their designs in a high-level and abstract manner, which can then be synthesised into physical designs by tools such as logic synthesisers and place-and-route tools.

\subsection{Register Transfer Level}
Designing hardware at a register transfer level (RTL) allows designers to express at a relatively low level the operations which are to happen in hardware synthesised from it. This involves using registers, which are a flip-flop and can be updated at each clock cycle, or wires, which are assumed to update instantly: set-up times are not considered at this point. This abstraction allows RTLs to describe the movement and modification of digital signals as they are `transferred' between registers. An RTL description is usually converted into a gate-level description by a synthesis tool, which can then be used for further processing like placement, routing, and bitstream generation, and many HLS compilers will target an RTL rather than synthesising the design themselves. RTL design is generally performed in languages such as Verilog and VHDL, which are considered lower level than many other types of HDL.

\subsection{High Level Synthesis}
High-Level Synthesis (HLS) is a method of designing hardware systems using a higher level of abstraction than RTL. HLS tools take descriptions of hardware described in high-level programming languages like C or C++, or in DSLs which allow hardware to be described in many different ways via many different abstractions, and synthesise them into RTL designs. This allows hardware designers to express complex algorithms succinctly and in a more software-like manner, reducing the time it takes to design and verify a system.

HLS tools generally cannot be used to create any given circuit, and therefore the languages are not technically HDLs. This is because it is a circuit which has the behaviour described in the program which is generated by the compiler, rather than an exact 1:1 mapping of variables and operations to wires and registers. To simplify the compilation process and limit the language to only concepts which are transferable to hardware, subsets or variants of these languages such as Single-Assignment C \cite{sa-c}, or the subset used by ROCCC \cite{5474060} are used.  Some languages used for HLS abstract away the concept of a clock, with the timing decided by the compiler; others keep the clock and leave it to the user to specify the timing of their design, which may or may not be tweaked by the compiler.

\subsubsection{Formal Verification}\label{formalverif}
Formal verification is an automated method for rigorously checking the correctness of a program. When applied to HLS, this program is a piece of hardware. It involves the use of mathematical methods to ensure that a given design adheres to its specified behaviour, eliminating the need for exhaustive simulation tests.

Formal verification can ensure that the functionality of a design matches its specifications, thereby reducing the likelihood of undetected design errors causing issues later on. Additionally, formal verification can also significantly speed up the testing process of a design, as simulations often require significant time to run. Simulations may not even cover all possible edge cases, whereas formal verification will.

Formal verification is easier to perform on programs in specific forms, and some HLS tools can perform formal verification on both the input and output programs. As Herklotz, Pollard, Ramanathan, and Wickerson discovered in their 2021 paper `Paper' \cite{formal_verif}, it is not uncommon for even commercially supported HLS tools such as Vivado \cite{vivado} to apply optimisations incorrectly, leading to the functionality of the synthesised hardware design not matching the HSL specification. By using a language and intermediate representation where formal verification are more straightforward it is possible to prove that an optimised design matches its high level specification.

Formal verification is especially useful in hardware as there are fewer error recovery and debugging mechanisms when compared to software \hyphen{} when in software one may just deploy a fix for reported malfunctioning software, it is unlikely to be immediately apparent that hardware is malfunctioning at all, and even then finding what the issue is is likely to be more of a challenge due to the lack of debugging software. On fabricated hardware, fixing bugs will result in the whole fabrication system, including any dies and tooling, needing to be replaced.

\subsection{Related Work in Hardware Development Languages}
\subsubsection{SystemVerilog}
SystemVerilog \cite{8299595} is a hardware description and verification language that extends and improves upon the Verilog language similarly to how C++ extends C in the software world. It offers a number of advanced features for modelling hardware, such as an enhanced type system when compared to Verilog, interfaces, and design hierarchy. SystemVerilog also introduces a comprehensive set of verification constructs, allowing for complex testbenches and verification environments to be built alongside the design itself. This makes it a popular choice for complex, safety-critical designs which require design at a register transfer level and necessitate formal verification.

\subsubsection{Survey of Domain-Specific Languages for FPGA Computing}
In the paper `Survey of Domain-Specific Languages for FPGA Computing' \cite{7577380}, Kapre and Bayliss present a comprehensive overview of the current state of DSLs targeted towards FPGA computing. They note that hardware languages lag far behind software languages in terms of the level of abstraction they provide as well as the tooling around these languages which enables developers be more productive when writing their code.

They explore the advantages and disadvantages of using DSLs over traditional HDLs, and identify trends and areas of ongoing research in the field. One key finding is the rise of spatial programming, a paradigm that treats hardware as a two-dimensional space and allows designers to express parallelism and locality explicitly. This approach is a departure from traditional sequential programming and offers significant performance advantages for hardware designs.

The survey also highlights the increasing sophistication of compiler and synthesis technologies, which are becoming more adept at translating high-level constructs into efficient hardware implementations. These advances are enabling DSLs to deliver competitive performance while offering higher productivity than traditional HDLs.

\subsubsection{LLHD}
LLHD (Low Level Hardware Description) \cite{mlir} is a language designed for digital hardware modelling. It provides a middle ground between high-level HDLs like SystemVerilog and gate-level netlists. Its lower level of abstraction enables detailed control of signal timing and operations, but it is more amenable to compiler analysis and transformations than traditional HDLs. This makes it particularly suited to verification, simulation, and as a target for HLS tools.

\subsubsection{CIRCT}
The Circuit IR Compilers and Tools project (CIRCT) \cite{circt} aims to apply MLIR and LLVM techniques to the domain of digital design tools. Its goal is to develop open-source tools that support a variety of hardware design and verification tasks. These tools work with a variety of input languages and aim to provide efficient and high-quality output for multiple backends. One of the key aspects of CIRCT is its support for and development of the LLHD intermediate representation, which it uses to enable sophisticated transformations and optimizations of digital designs.