
\noindent
\textbf{Note:} I plan to expand this section with better/more in-depth explanations as it becomes clearer which are immediately relevant to my project - I will almost certainly also add/remove sections.
\section{Hardware Design Languages}
\subsection{Register Transfer Languages}
Register transfer languages (RTLs) express at a low level the operations which are to happen in hardware synthesised from it. This involves using registers, which are a flip-flop and can be updated at each clock cycle, or wires, which are assumed update instantly: set-up times are not considered at this point. RTLs are generally the last stages before synthesis, and most HLS compilers will target an RTL rather than synthesising the design themselves.

\subsection{High Level Synthesis}
High level synthesised languages, unlike RTLs, often take languages traditionally used for programming software, and compile this to hardware or RTLs. HLS generally cannot be used to create any given circuit, and therefore the languages are not technically HDLs. This is because it is a circuit which has the behaviour described in the program which is generated by the compiler, rather than an exact 1:1 mapping of variables and operations to wires and registers. To simplify the compilation process and limit the language to only concepts which are transferable to hardware, subsets or variants of these languages such as Single-Assignment C \cite{sa-c} or the subset used by ROCCC \cite{5474060} are used. Some languages used for HLS abstract away the concept of a clock, with the timing decided by the compiler; others keep the clock and leave it to the user to specify the timing of their design, which may or may not be tweaked by the compiler.

\section{Static Streaming Hardware}
Static streaming hardware is a hardware extension of the concept of stream processing. Inputs to the hardware device are provided at a constant and known rate, and the outputs are provided at the same rate. It is possible to have multiple output streams, a single output stream or even a single output at the end of the input stream. In the case of there being a single scalar output, the concept is similar, however the output stream is simply immobile with regards to where it is written to - eg. for a sum of a list, the sum of any given initial subsection can be seen by viewing this output at the correct time.

\noindent
The ``static'' in static streaming hardware refers to the fact that the full program and available memory is known in hardware: external factors cannot add functionality to the hardware. This does not mean that branching cannot occur - branches can be created at any time by using multiplexers, however the inputs to these multiplexers must depend on the inputs to the hardware and not any runtime configuration. Multiple inputs of either scalar or streaming form can be used in the hardware, with scalar inputs being treated as a stream with a constant value until it updates; branches can also be used by using the output of operations more than once, eg. in the case of \lstinline|int x = 5; int y = x + x;|, x is branched to give 2 inputs to \lstinline|+|.

\subsection{Static Streaming Dataflow Graphs}
Static streaming dataflow graphs are used to represent the transformations applied to the input stream to produce the output stream. These are broken down to the operation level, generally with 1 operation happening per clock cycle for demonstration purposes, however this may not actually be the case for some more complex operations, eg. division and multiplication. Examples of static streaming dataflow graphs can be seen in Figures \ref{dataflow.maxj.mvg-avg} and \ref{dataflow.pseudocode.mvg-avg}.

\section{IR Framework}
In the context of this paper, an intermediate representation (IR) framework is a software library for representing and performing optimisations on an IR. The two considered by this paper are xDSL \cite{xdsl-home} and MLIR \cite{mlir}, both of which feature ``dialects'', which can be used in conjunction to represent concepts in the IR. Once the code is represented only in the ``lowest level'' built-in dialects, the target language is emitted - this can be any architecture, IR, bytecode, HDL or other language the framework has ``bindings'' for.

\subsection{Dialects}
Dialects of IR frameworks allow for new expressions, types and more to be added to the ``base'' IR. These dialects can be as simple as adding basic integer arithmetic, as added to xDSL or MLIR by the \textit{arith} dialect, or more complex such as the \textit{async}, \textit{amdgpu} or \textit{affine} dialects, which add parallelism, graphics processing for AMD GPUs and functional higher-order collection functions respectively. Optimisations and code analysis are run per-dialect, and generally a more complex dialect will emit a simpler one once it has finished processing the code.

\section{Related Work}
\subsection{Design and Optimisation of Behavioral Dataflows}

